<#@ template  debug="true" language="C#" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ include file="TemplateFileManagerV2.1.ttinclude" #>
<#@ include file="brace.ttinclude" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="Model" #> 
<#@ import namespace="Shared" #> 
<#@ assembly name="$(ProjectDir)..\bin\Debug\Model.dll" #>
<#@ assembly name="$(ProjectDir)..\bin\Debug\Shared.dll" #>
<#@ import namespace="System.Reflection" #>
<#@ assembly name="EnvDte" #>
<#@ newAppDomain processor="tangibleT4Editor" #>


<#
	// required to output to multiple files
	manager = TemplateFileManager.Create(this);

	var trackableType = typeof(ITrackable);

	// Get a list of Types that implement ITrackable
	var types = AppDomain.CurrentDomain.GetAssemblies().ToList().SelectMany(s => s.GetTypes()).Where(p => p != trackableType && trackableType.IsAssignableFrom(p));
	var typeNames  = types.Select(x => x.Name);

	foreach(var type in types)
	{
		CreateTrackableObjectClass(type,typeNames);
	}

	// outfile to files
	manager.Process();
#>

<#+
	private TemplateFileManager manager;
	private const string _prefix = "Trackable"; // change this to alter the output class names 
	private const string _namespaceName = "Model";
	
	private void CreateTrackableObjectClass(Type type, IEnumerable<string> typeNames)
	{
		manager.StartNewFile(_prefix + type.Name + ".cs");
		CreateUsingStatements();
		var properties = GetPublicPropertyDetails(type);

		using(new Brace("namespace " + _namespaceName, this)){
		
				using(new Brace("public class " + "Trackable" + type.Name + " : INotifyPropertyChanged, IChangeTracking", this)){

						CreateConstructor(type, properties, typeNames);

						CreateProperties(properties);

						CreateINotifyPropertyChangedRegion();

						CreateIChangeTrackingRegion(properties);
				}
		 }
	}

	private Dictionary<string, string> GetPublicPropertyDetails(Type type)
	{
		var properties = new Dictionary<string,string>();

		foreach (PropertyInfo property in type.GetProperties())
		{
			var typeName = StringExtensions.GetFriendlyName(property.PropertyType);
			properties.Add(property.Name,typeName);
		}

		return properties;
	}

	private void CreateUsingStatements()
	{
		WriteLine(@"using Model;");
		WriteLine("using Shared;");
		WriteLine("using System;");
		WriteLine("using System.Collections.Generic;");
		WriteLine("using System.ComponentModel;");
		WriteLine("using System.Runtime.CompilerServices;");

		WriteLine(Environment.NewLine);
	}

	private void CreateConstructor(Type type, Dictionary<string,string> properties, IEnumerable<string> typeNames)
	{
		var camelCaseName = StringExtensions.ToCamelCase(type.Name);

		// parameterless constructor
		using(new Brace("public " + _prefix + type.Name + "()", this)){
			
			foreach (var kvp in properties)
			{
				var isTrackable = IsTypeTrackable(kvp.Value,typeNames);
				CreatePropertyInitializer(kvp.Key,kvp.Value, isTrackable);
			}
		}

		WriteLine(Environment.NewLine);

		using(new Brace("public " + _prefix + type.Name + "(" + type.Name + " " + camelCaseName + ")", this)){
			
			foreach (var kvp in properties)
			{
				WriteLine("_original" + kvp.Key + " = " + camelCaseName +  "." + kvp.Key + ";");
			}
		}
		
		WriteLine(Environment.NewLine);
	}

	/// Used to initialize variables inside of the class constructor
	private void CreatePropertyInitializer(string propertyName, string propertyType, bool isTypeTrackable)
	{
		Write(propertyName + " = ");
		
		switch(propertyType)
		{
			 
				case "int":
				case "short":
				case "byte":
				case "bool":
				case "long":
				case "float":
				case "double":
				case "decimal":
				case "string":
					WriteLine("default(" + propertyType + ");");
					break;
				default:
					
					if (propertyType.EndsWith("?"))
					{
						WriteLine("null;");
					}
					else
					{
						WriteLine("new " + propertyType + "();");
					}

					break;
		}
	}

	// e.g. List<string> returns "string"
	private string GetGenericTypeParameter(string genericTypeName)
	{
	
			string typeParameter = string.Empty;

			var regex = new Regex(@"\<(?<name>\S+)\>");
		   
			// Assume only one type parameter at the moment
			// TODO handle dictionaries and other stuff, e.g. Dicionary<string,List<string>>
			if (regex.IsMatch(genericTypeName))
			{
				typeParameter = regex.Matches(genericTypeName)[0].Groups["name"].Value;
			}

			return typeParameter;
	}

	// e.g. return "List" from "List<SomeType>" or "Dictionary" from "Dictionary<string,string>"
	private string GetGenericType(string genericTypeName)
	{
	
			string typeName = string.Empty;

			var regex = new Regex(@"(?<name>\S+)\<\S+\>");
		   
			// Assume only one type at the moment
			// TODO handle nested lists/dictionaries and other stuff
			if (regex.IsMatch(genericTypeName))
			{
				typeName = regex.Matches(genericTypeName)[0].Groups["name"].Value;
			}

			return typeName;
	}

	// Loop through all the public properties
	private void CreateProperties(Dictionary<string,string> properties)
	{
		foreach (var property in properties)
		{
			CreateProperty(property.Key,property.Value);
		}
	}

	// Create public property with propertychanged, can tracking etc
	private void CreateProperty(string propertyName, string propertyType)
	{
		var privateFieldName = "_" + StringExtensions.ToCamelCase(propertyName);
		// private backing field
		WriteLine("private " + propertyType + " " + privateFieldName + ";");
		// original value field
		WriteLine("private " + propertyType + " _original" + propertyName + ";");

		// public property
		using(new Brace("public " + propertyType + " " + propertyName,this))
		{
				using(new Brace("get",this))
				{
					WriteLine("return " + privateFieldName + ";");
				}
				
				using(new Brace("set",this))
				{
					using(new Brace("if (" + privateFieldName + " != value)", this))
					{
						WriteLine(privateFieldName + " = value;");
						WriteLine(@"OnPropertyChanged(""" + propertyName + @""");");
						using(new Brace("if (_original" + propertyName + " != " + privateFieldName + ")",this))
						{
							WriteLine("IsChanged = true;");
						}
					}
				}
		}

		WriteLine(Environment.NewLine);
	}

	
	// return true if this type is going to have a trackable object class generated by the T4 template
	private bool IsTypeTrackable(string typeName, IEnumerable<string> typeNames)
	{
		return typeNames.Any(x => x == typeName);
	}

	private void CreateINotifyPropertyChangedRegion()
	{
		WriteLine(@"
#region INotifyPropertyChanged

public event PropertyChangedEventHandler PropertyChanged;

protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
{
	PropertyChangedEventHandler handler = PropertyChanged;
	if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));
}

#endregion
");
	}

	private void CreateIChangeTrackingRegion(Dictionary<string,string> properties)
	{
		WriteLine(@"#region IChangeTracking" + Environment.NewLine);
		using(new Brace("public void AcceptChanges()",this))
		{
			foreach(var property in properties)
			{
				WriteLine("_original" + property.Key + " = _" + StringExtensions.ToCamelCase(property.Key) + ";");
			}

				WriteLine("IsChanged = false;");
		}
	
		WriteLine(@"

private bool _isChanged;
public bool IsChanged
{
	get 
	{ 
		return _isChanged;
	}
	set
	{
		if (_isChanged != value)
		{
			_isChanged = value;
			OnPropertyChanged(""IsChanged"");
		}
	}
}
		
#endregion"
		);
	}
#>