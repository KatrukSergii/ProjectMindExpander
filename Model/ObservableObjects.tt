<#@ template  debug="true" language="C#" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ include file="TemplateFileManagerV2.1.ttinclude" #>
<#@ include file="brace.ttinclude" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="Model" #> 
<#@ import namespace="Shared.Utility" #> 
<#@ assembly name="$(ProjectDir)..\bin\Debug\Model.dll" #>
<#@ assembly name="$(ProjectDir)..\bin\Debug\Shared.dll" #>
<#@ import namespace="System.Reflection" #>
<#@ assembly name="EnvDte" #>
<#@ newAppDomain processor="tangibleT4Editor" #>


<#
// NB: 
//	+ Only handles List<T> at the moment (no HashSets, Collections etc) 
//  + Only generic type tested is List<T>. List<T> is converted to ObservableCollection<T> by the template
//  + TODO remove INotifyPropertyChanged and IChangeTracking casts - should know this type information at generation so it is redundant
// 	+ Assumes that reference types implement IEqualityComparer
//	+ Assumes that reference types have parameterless constructors
//  + Assumes c# type aliases are used (e.g. string, int, bool not Int32  etc)

	// required to output to multiple files
	manager = TemplateFileManager.Create(this);

	var ObservableType = typeof(IObservable);

	// Get a list of Types that implement IObservable
	var types = AppDomain.CurrentDomain.GetAssemblies().ToList().SelectMany(s => s.GetTypes()).Where(p => p != ObservableType && ObservableType.IsAssignableFrom(p));
	var typeNames  = types.Select(x => x.Name);

	foreach(var type in types)
	{
		CreateObservableObjectClass(type,typeNames);
	}

	// outfile to files
	manager.Process();
#>

<#+
	private TemplateFileManager manager;
	private const string _prefix = "Observable"; // change this to alter the output class names 
	private const string _namespaceName = "Model";
	
	private void CreateObservableObjectClass(Type type, IEnumerable<string> typeNames)
	{
		manager.StartNewFile(_prefix + type.Name + ".cs");
		CreateUsingStatements();
		var properties = GetPublicPropertyDetails(type);

		using(new Brace("namespace " + _namespaceName, this)){

				WriteLine("[Serializable]");		
				using(new Brace("public partial class " + "Observable" + type.Name + " : INotifyPropertyChanged, IChangeTracking", this)){

						CreatePrivateMembers();

						CreateConstructor(type, properties, typeNames);

						CreateProperties(properties, typeNames);

						CreateResetPropertiesMethod(properties, typeNames);
						CreateINotifyPropertyChangedRegion();

						CreateIChangeTrackingRegion(properties);
				}
		 }
	}

	private void CreatePrivateMembers()
	{
		WriteLine("private Dictionary<string,bool> _changeTracker;");
		WriteLine("private bool _isTrackingEnabled;");
		WriteLine(Environment.NewLine);
	}

	private Dictionary<string, string> GetPublicPropertyDetails(Type type)
	{
		var properties = new Dictionary<string,string>();

		foreach (PropertyInfo property in type.GetProperties())
		{
			// removes any rubbish from the generic type name 
			var typeName = StringHelper.GetFriendlyName(property.PropertyType);
			properties.Add(property.Name,typeName);
		}

		return properties;
	}

	private void CreateUsingStatements()
	{
		//WriteLine(@"using Model;");
		//WriteLine("using Shared;");
		WriteLine("using Shared.Utility;");
		//WriteLine("using Shared.DataStructures;");
		WriteLine("using System;");
		WriteLine("using System.Linq;");
		WriteLine("using System.ComponentModel;");
		WriteLine("using System.Collections.Generic;");
		WriteLine("using System.Collections.ObjectModel;");
		WriteLine("using System.Collections.Specialized;");
		WriteLine("using System.Runtime.CompilerServices;");
		
		WriteLine(Environment.NewLine);
	}

	private void CreateConstructor(Type type, Dictionary<string,string> properties, IEnumerable<string> typeNames)
	{
		var camelCaseName = StringHelper.ToCamelCase(type.Name);

		// parameterless constructor, e.g. ObservableFoo()
		using(new Brace("public " + _prefix + type.Name + "()", this)){
			
			WriteLine("InitializeChangeTracker();");

			foreach (var kvp in properties)
			{
				var isObservable = TypeUtility.IsTypeObservable(kvp.Value,typeNames);
				CreatePropertyInitializer(kvp.Key,kvp.Value, isObservable);
			}
		}

		WriteLine(Environment.NewLine);

		var collectionPropertyNames = new Dictionary<string,string>();

		// e.g.  ObservableFoo(Foo foo)
		using(new Brace("public " + _prefix + type.Name + "(" + type.Name + " " + camelCaseName + ") : this()", this)){

			// Assign the _originalX properties
			foreach (var kvp in properties)
			{
				var genericType = TypeUtility.ConvertTypeNameToObservableTypeName(kvp.Value,typeNames,_prefix);

				Write("_original" + kvp.Key + " = ");

				// if the type starts with 'Observable' we need to new up the object in the constructor, e.g _originalX = new ObservableFoo();
				if (genericType.StartsWith(_prefix))
				{
					var genericParam = TypeUtility.GetGenericTypeParameter(kvp.Value);

					if (genericType.StartsWith("ObservableCollection"))
					{
						collectionPropertyNames.Add(kvp.Key, TypeUtility.ConvertTypeNameToObservableTypeName(genericParam,typeNames,_prefix));
					}

					//e.g. _originalFoos = new ObservableCollection<ObservableFoo>(myObject.Foos.Select(x => new ObservableFoo(x)).ToList());

					var constructorParam = camelCaseName +  "." + kvp.Key;
					if (TypeUtility.IsTypeObservable(genericParam, typeNames))
					{
						genericParam = TypeUtility.ConvertTypeNameToObservableTypeName(genericParam,typeNames,_prefix);
						constructorParam = constructorParam + ".Select(x => new " + genericParam + "(x)).ToList()";
					}

					WriteLine("new " + genericType + "(" + constructorParam + ");");
				}
				else
				{
					WriteLine(camelCaseName +  "." + kvp.Key + ";");
				}
			}

			WriteLine(Environment.NewLine);
			WriteLine("// Set the properties to the _original property values");
			WriteLine("ResetProperties();");
			foreach(var prop in collectionPropertyNames)
			{
				WriteLine(prop.Key + ".CollectionChanged += " + prop.Key + "_CollectionChanged;");
			}
			WriteLine("//TODO hook up  all of the property changed events for non-collection reference types");

			foreach(var prop in collectionPropertyNames)
            {
				if (!TypeUtility.IsValueType(prop.Value))
                {
					using(new Brace("foreach(var item in " + prop.Key + ")",this))
					{
						WriteLine("var propertyChangedItem = item as INotifyPropertyChanged;");
						using(new Brace("if(propertyChangedItem != null)",this))
						{
							WriteLine("propertyChangedItem.PropertyChanged += " + prop.Key + "_Item_PropertyChanged;");
						}
					}
					WriteLine(Environment.NewLine);
                }
            }

			WriteLine("ResetChangeTracking();");
			WriteLine("_isTrackingEnabled = true;");
		}
		
		WriteLine(Environment.NewLine);
		 
		// Create the collection changed and property changed event handlers
		foreach(var prop in collectionPropertyNames)
		{
			CreateCollectionChangedEventHandler(prop.Key, prop.Value);
			CreateCollectionItemChangedEventHandler(prop.Key, prop.Value);
		}
	}

	private void CreateCollectionChangedEventHandler(string propertyName, string collectionType)
    {
		using(new Brace("private void " + propertyName + "_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)",this))
        {
			WriteLine(@"_changeTracker[""" + propertyName + @"""] = true;");
			WriteLine(Environment.NewLine);
			using(new Brace("switch(e.Action)",this))
            {
				WriteLine("case NotifyCollectionChangedAction.Remove:");
				WriteLine("case NotifyCollectionChangedAction.Replace:");
				PushIndent("\t");
				using(new Brace("foreach(var item in e.OldItems)",this))
                {
					WriteLine("var propertyChangedItem = item as INotifyPropertyChanged;");
					using(new Brace("if (propertyChangedItem != null)",this))
                    {
						WriteLine("propertyChangedItem.PropertyChanged -= " + propertyName + "_Item_PropertyChanged;");
                    }
					WriteLine("else");
					using(new Brace("",this))
                    {
						WriteLine(@"_changeTracker[""" + propertyName + @"""] = !ListUtilities<" + collectionType + ">.EqualTo(_original" + propertyName + "," + propertyName + ");");
						WriteLine(@"OnPropertyChanged(""IsChanged"");");
                    }
                }

				WriteLine("break;");
				PopIndent();
				WriteLine("case NotifyCollectionChangedAction.Add:");
				PushIndent("\t");
				using(new Brace("foreach(var item in e.NewItems)",this))
                {
					WriteLine("var propertyChangedItem = item as INotifyPropertyChanged;");
					using(new Brace("if (propertyChangedItem != null)",this))
                    {
						WriteLine("propertyChangedItem.PropertyChanged +=" + propertyName + "_Item_PropertyChanged;");
                    }
                }
				WriteLine(@"_changeTracker[""" + propertyName + @"""] = !ListUtilities<" + collectionType + ">.EqualTo(_original" + propertyName + "," + propertyName + ");");
				WriteLine(@"OnPropertyChanged(""IsChanged"");");
				WriteLine("break;");
				PopIndent();
            }
		}
		WriteLine(Environment.NewLine);
    }

	private void CreateCollectionItemChangedEventHandler(string propertyName, string collectionType)
    {
		using(new Brace("private void " + propertyName + "_Item_PropertyChanged(object sender, PropertyChangedEventArgs e)",this))
        {
			WriteLine("var trackingItem = sender as IChangeTracking;");
			using(new Brace("if (trackingItem != null)",this))
            {
				WriteLine(@"_changeTracker[""" + propertyName + @"""] = trackingItem.IsChanged;");
				WriteLine(@"OnPropertyChanged(""IsChanged"");");
			}
			WriteLine("else");
			using(new Brace("",this))
            {
						WriteLine(@"_changeTracker[""" + propertyName + @"""] = !ListUtilities<" + collectionType + ">.EqualTo(_original" + propertyName + "," + propertyName + ");");
						WriteLine(@"OnPropertyChanged(""IsChanged"");");
            }
        }

		WriteLine(Environment.NewLine);
    }

	/// Used to initialize variables inside of the parameterless class constructor
	private void CreatePropertyInitializer(string propertyName, string propertyType, bool isTypeObservable)
	{
		Write(propertyName + " = ");
		
		switch(propertyType)
		{
			 
				case "int":
				case "short":
				case "byte":
				case "bool":
				case "long":
				case "float":
				case "double":
				case "decimal":
				case "string":
					WriteLine("default(" + propertyType + ");");
					break;
				default:
					
					// if type is nullable or a list then just set to null
					if (propertyType.EndsWith("?") || TypeUtility.GetGenericType(propertyType).Equals("List"))
					{
						WriteLine("null;");
					}
					else
					{
						WriteLine("new " + (isTypeObservable ? _prefix + propertyType : propertyType) + "();");
					}

					break;
		}
	}

	
	// Loop through all the public properties
	private void CreateProperties(Dictionary<string,string> properties, IEnumerable<string> typeNames)
	{
		foreach (var property in properties)
		{
			string type = TypeUtility.ConvertTypeNameToObservableTypeName(property.Value,typeNames,_prefix);
			CreateProperty(property.Key,type);
		}
	}

	// Create public property with propertychanged, can tracking etc
	private void CreateProperty(string propertyName, string propertyType)
	{
		var privateFieldName = "_" + StringHelper.ToCamelCase(propertyName);
		// private backing field
		WriteLine("private " + propertyType + " " + privateFieldName + ";");
		// original value field
		WriteLine("private " + propertyType + " _original" + propertyName + ";");

		// public property
		using(new Brace("public " + propertyType + " " + propertyName,this))
		{
				using(new Brace("get",this))
				{
					WriteLine("return " + privateFieldName + ";");
				}
				
				using(new Brace("set",this))
				{
					using(new Brace("if (" + privateFieldName + " != value)", this))
					{
						WriteLine(privateFieldName + " = value;");
						WriteLine(@"OnPropertyChanged(""" + propertyName + @""");");

						using(new Brace("if (_original" + propertyName + " == null || !_original" + propertyName + ".Equals(" + privateFieldName + "))",this))
						{
							WriteLine(@"_changeTracker[""" + propertyName + @"""] = true;");
							WriteLine(@"OnPropertyChanged(""IsChanged"");");
						}
						using (new Brace("else", this))
						{
							WriteLine(@"_changeTracker[""" + propertyName + @"""] = false;");
						}
					}
				}
		}

		WriteLine(Environment.NewLine);
	}

	private void CreateResetPropertiesMethod(Dictionary<string,string> properties, IEnumerable<string> typeNames)
	{
		using(new Brace("private void ResetProperties()",this))
		{
			
			foreach (var kvp in properties)
			{
				
				if (TypeUtility.IsValueType(kvp.Value))
				{
					WriteLine(kvp.Key + " = _original" + kvp.Key + ";");
				}
				else
				{
					// Reference Types need to be deep copied
					var observableTypeName = TypeUtility.ConvertTypeNameToObservableTypeName(kvp.Value, typeNames, _prefix);
					if (observableTypeName.StartsWith("ObservableCollection"))
					{
						var collectionIsValueType = TypeUtility.IsValueType(TypeUtility.GetGenericTypeParameter(observableTypeName));
						if (!collectionIsValueType)
                        {
							WriteLine("// Unhook propertyChanged eventhandlers for " + kvp.Key);
							using(new Brace("if (" + kvp.Key + " != null)", this))
							{
								using (new Brace("foreach(var item in " + kvp.Key + ")", this))
								{
									WriteLine("var propertyChangedItem = item as INotifyPropertyChanged;");
									using(new Brace("if(propertyChangedItem != null)",this))
									{
										WriteLine("propertyChangedItem.PropertyChanged -= " + kvp.Key + "_Item_PropertyChanged;");
									}
								}
							}
                        }
					}

					Write(kvp.Key + " = _original" + kvp.Key + " == null ? null : ");
					
					if(observableTypeName.StartsWith(_prefix + "List"))
					{
						WriteLine("_original" + kvp.Key + ".DeepCopy();" );  // ObservableList has a method to deep copy all the items and return a new list
					}
					else
					{
							WriteLine("GenericCopier<" + observableTypeName + ">.DeepCopy(_original" + kvp.Key + ");" );
					}

					if (observableTypeName.StartsWith("ObservableCollection"))
					{
						var collectionIsValueType = TypeUtility.IsValueType(TypeUtility.GetGenericTypeParameter(observableTypeName));
						if (!collectionIsValueType)
                        {
							WriteLine("// Hook-up propertyChanged eventhandlers for " + kvp.Key);
							using(new Brace("if (" + kvp.Key + " != null)", this))
							{
								using (new Brace("foreach(var item in " + kvp.Key + ")", this))
								{
									WriteLine("var propertyChangedItem = item as INotifyPropertyChanged;");
									using(new Brace("if(propertyChangedItem != null)",this))
									{
										WriteLine("propertyChangedItem.PropertyChanged += " + kvp.Key + "_Item_PropertyChanged;");
									}
								}
							}
                        }
					}
				}
			}
		}
		WriteLine(Environment.NewLine);
	}

	private void CreateINotifyPropertyChangedRegion()
	{
		WriteLine(@"
#region INotifyPropertyChanged

[field:NonSerializedAttribute()]
public event PropertyChangedEventHandler PropertyChanged;

protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
{
	if (_isTrackingEnabled)
	{
		PropertyChangedEventHandler handler = PropertyChanged;
		if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));
	}
}

#endregion
");
	}

	private void CreateIChangeTrackingRegion(Dictionary<string,string> properties)
	{
		WriteLine(@"#region IChangeTracking" + Environment.NewLine);
		using(new Brace("public void AcceptChanges()",this))
		{
			foreach(var property in properties)
			{
				WriteLine("_original" + property.Key + " = _" + StringHelper.ToCamelCase(property.Key) + ";");
			}

			WriteLine("ResetChangeTracking();");
		}
	
		WriteLine(Environment.NewLine);

		using(new Brace("public void AbandonChanges()",this))
		{
			WriteLine("_isTrackingEnabled = false;");
			WriteLine("ResetProperties();");
			WriteLine("_isTrackingEnabled = true;");
			WriteLine("ResetChangeTracking();");
		}
	
		WriteLine(Environment.NewLine);

		using(new Brace("private void InitializeChangeTracker()", this))
		{
			WriteLine("_changeTracker = new Dictionary<string,bool>();");
			foreach(var property in properties)
			{
				WriteLine(@"_changeTracker[""" + property.Key + @"""] = false;");
			}
		}

		WriteLine(@"

private void ResetChangeTracking()
{
	foreach (string key in _changeTracker.Keys.ToList())
	{
		_changeTracker[key] = false;
	}
}

public bool IsChanged
{
	get 
	{ 
		return _changeTracker.Any(x => x.Value == true);
	}
	private set
	{
		throw new InvalidOperationException(""Cannot set IsChanged property"");
	}
}
		
#endregion"
		);
	}
#>