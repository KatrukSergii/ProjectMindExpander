using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace Shared.Utility
{
    public static class TypeUtility
    {
        private static readonly Regex GenericTypeRegex = new Regex(@"(?<type>\w+)\<(?<parameter>\S+)\>$");
        private static readonly Regex GenericTypeParameterRegex = new Regex(@"\<(?<type>\S+)\>");

        // e.g. List<string> returns "string"
        public static string GetGenericTypeParameter(string genericTypeName)
        {

            string typeParameter = string.Empty;

            // Assume only one type parameter at the moment
            // TODO handle dictionaries and other stuff, e.g. Dicionary<string,List<string>>
            if (GenericTypeParameterRegex.IsMatch(genericTypeName))
            {
                typeParameter = GenericTypeParameterRegex.Matches(genericTypeName)[0].Groups["type"].Value;
            }

            return typeParameter;
        }

        // e.g. return "List" from "List<SomeType>" or "Dictionary" from "Dictionary<string,string>"
        public static string GetGenericType(string genericTypeName)
        {
            string typeName = string.Empty;

            // Assume only one type at the moment
            // TODO handle nested lists/dictionaries and other stuff
            if (GenericTypeRegex.IsMatch(genericTypeName))
            {
                typeName = GenericTypeRegex.Matches(genericTypeName)[0].Groups["type"].Value;
            }

            return typeName;
        }

        /// <summary>
        /// e.g. List<Foo> -> ObservableList<ObservableFoo>
        /// or List<string> -> ObservableList<string>
        /// or Foo -> ObservableFoo
        /// </summary>
        /// <param name="type">e.g. "List<Foo>"</param>
        /// <param name="typeNames">List of types that have Observable wrapper classes</param>
        /// <param name="prefix">string to prepend on type names (i.e. "Observable")</param>
        /// <returns></returns>
        public static string ConvertTypeNameToObservableTypeName(string type, IEnumerable<string> typeNames, string prefix)
        {
            var genericType = TypeUtility.GetGenericType(type);
            if (string.IsNullOrEmpty(genericType))
            {
                if (IsTypeObservable(type, typeNames))
                {
                    return prefix + type;
                }
                return type;
            }

            if (genericType.Equals("List") || IsTypeObservable(genericType, typeNames))
            {
                genericType = prefix + genericType;
            }

            var genericTypeParameter = TypeUtility.GetGenericTypeParameter(type);

            if (!string.IsNullOrEmpty(TypeUtility.GetGenericType(genericTypeParameter)))
            {
                // recursive call in case of nested generic types; e.g. List<List<string>>
                genericTypeParameter = ConvertTypeNameToObservableTypeName(genericTypeParameter, typeNames, prefix);
            }

            if (!string.IsNullOrEmpty(genericTypeParameter) && IsTypeObservable(genericTypeParameter, typeNames))
            {
                genericTypeParameter = prefix + genericTypeParameter;
            }

            var returnTypeName =  genericType + "<" + genericTypeParameter + ">";
            return returnTypeName;
        }

        /// <summary>
        /// return true if this type is going to have a Observable object class generated by the T4 template
        /// </summary>
        /// <param name="typeName">Type name to check for</param>
        /// <param name="typeNames">List of type names that will have generated Observable wrapper classes</param>
        /// <returns></returns>
        public static bool IsTypeObservable(string typeName, IEnumerable<string> typeNames)
        {
            return typeNames.Any(x => x == typeName);
        }

        /// <summary>
        /// Returns true if the string representing a type name is 
        /// </summary>
        /// <param name="typeName"></param>
        /// <returns></returns>
        public static bool IsValueType(string typeName)
        {
            switch (typeName.ToLower())
            {
                case "int":
                case "short":
                case "byte":
                case "bool":
                case "long":
                case "float":
                case "double":
                case "decimal":
                case "string": // treat string as a value type
                case "timespan":
                    return true;
                default:
                    return false;
            }
        }
    }
}
